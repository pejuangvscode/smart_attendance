<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/smartattendance/api/AttendanceApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/smartattendance/api/AttendanceApi.kt" />
              <option name="originalContent" value="package com.example.smartattendance.api&#10;&#10;import io.github.jan.supabase.SupabaseClient&#10;import io.github.jan.supabase.postgrest.postgrest&#10;import io.github.jan.supabase.postgrest.query.*&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import kotlinx.serialization.Serializable&#10;&#10;class AttendanceApi(private val supabase: SupabaseClient) {&#10;&#10;    // Data class for attendance record&#10;    @Serializable&#10;    data class AttendanceRecord(&#10;        val attendance_id: Int? = null,&#10;        val enrollment_id: Int,&#10;        val schedule_id: Int,&#10;        val attendance_date: String,&#10;        val status: String,&#10;        val is_verified: Boolean = false,&#10;        val recorded_at: String? = null&#10;    )&#10;&#10;    @Serializable&#10;    data class EnrollmentResult(val enrollment_id: Int)&#10;&#10;    @Serializable&#10;    data class CourseData(&#10;        val course_name: String&#10;    )&#10;&#10;    // Submit attendance - check if exists, if not create, if exists update is_verified&#10;    suspend fun submitAttendance(&#10;        userId: String,&#10;        scheduleId: Int,&#10;        courseId: Int&#10;    ): Result&lt;Pair&lt;String, String&gt;&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Get enrollment_id&#10;            val enrollmentResult = supabase.postgrest[&quot;enrollments&quot;]&#10;                .select(columns = Columns.list(&quot;enrollment_id&quot;)) {&#10;                    filter {&#10;                        eq(&quot;user_id&quot;, userId)&#10;                        eq(&quot;course_id&quot;, courseId)&#10;                    }&#10;                }&#10;                .decodeList&lt;EnrollmentResult&gt;()&#10;            if (enrollmentResult.isEmpty()) {&#10;                return@withContext Result.failure(Exception(&quot;User is not enrolled in this course&quot;))&#10;            }&#10;            val enrollmentId = enrollmentResult.first().enrollment_id&#10;            val today = LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE)&#10;            // Check if attendance record already exists&#10;            val existingAttendance = supabase.postgrest[&quot;attendances&quot;]&#10;                .select(columns = Columns.list(&quot;attendance_id&quot;, &quot;is_verified&quot;, &quot;from_camera&quot;, &quot;recorded_at&quot;, &quot;status&quot;)) {&#10;                    filter {&#10;                        eq(&quot;enrollment_id&quot;, enrollmentId)&#10;                        eq(&quot;schedule_id&quot;, scheduleId)&#10;                        eq(&quot;attendance_date&quot;, today)&#10;                    }&#10;                }&#10;                .decodeList&lt;AttendanceResultWithCameraTime&gt;()&#10;            if (existingAttendance.isEmpty()) {&#10;                // Aturan 1: Insert new attendance row, status 'pending'&#10;                supabase.postgrest[&quot;attendances&quot;]&#10;                    .insert(AttendanceRecord(&#10;                        enrollment_id = enrollmentId,&#10;                        schedule_id = scheduleId,&#10;                        attendance_date = today,&#10;                        status = &quot;pending&quot;&#10;                    ))&#10;                return@withContext Result.success(Pair(&quot;Attendance submitted, waiting for verification&quot;, &quot;pending&quot;))&#10;            } else {&#10;                val attendance = existingAttendance.first()&#10;                // Aturan 4: Jika status bukan pending dan is_verified true, langsung redirect&#10;                if (attendance.status != &quot;pending&quot; &amp;&amp; attendance.is_verified) {&#10;                    return@withContext Result.success(Pair(&quot;Attendance already verified&quot;, attendance.status))&#10;                }&#10;                // Aturan 2: Jika is_verified false dan from_camera true&#10;                if (!attendance.is_verified &amp;&amp; attendance.from_camera) {&#10;                    // Get schedule start time&#10;                    val scheduleResult = supabase.postgrest[&quot;schedules&quot;]&#10;                        .select(columns = Columns.list(&quot;start_time&quot;)) {&#10;                            filter { eq(&quot;schedule_id&quot;, scheduleId) }&#10;                        }&#10;                        .decodeList&lt;ScheduleStartTime&gt;()&#10;                    val scheduleStart = scheduleResult.firstOrNull()?.start_time ?: &quot;07:15&quot;&#10;                    // Compare recorded_at time with schedule start time + 15 min&#10;                    val attendanceTime = attendance.recorded_at?.substring(11,16) ?: scheduleStart&#10;                    val startHour = scheduleStart.substring(0,2).toInt()&#10;                    val startMin = scheduleStart.substring(3,5).toInt()&#10;                    val toleranceHour = attendanceTime.substring(0,2).toInt()&#10;                    val toleranceMin = attendanceTime.substring(3,5).toInt()&#10;                    val startTotalMin = startHour * 60 + startMin&#10;                    val attendTotalMin = toleranceHour * 60 + toleranceMin&#10;                    val statusResult = if (attendTotalMin &lt;= startTotalMin + 15) &quot;present&quot; else &quot;late&quot;&#10;                    // Update is_verified and status&#10;                    supabase.postgrest[&quot;attendances&quot;]&#10;                        .update({&#10;                            set(&quot;is_verified&quot;, true)&#10;                            set(&quot;status&quot;, statusResult)&#10;                        }) {&#10;                            filter { eq(&quot;attendance_id&quot;, attendance.attendance_id) }&#10;                        }&#10;                    return@withContext Result.success(Pair(&quot;Attendance verified successfully&quot;, statusResult))&#10;                }&#10;                // Aturan 3: Jika is_verified false dan from_camera false&#10;                // This block is only reached if above conditions are not met&#10;                return@withContext Result.success(Pair(&quot;Attendance submitted, waiting for verification&quot;, &quot;pending&quot;))&#10;            }&#10;        } catch (_: Exception) {&#10;            return@withContext Result.failure(Exception(&quot;Attendance submission failed&quot;))&#10;        }&#10;    }&#10;&#10;    @Serializable&#10;    data class AttendanceResultWithCameraTime(&#10;        val attendance_id: Int,&#10;        val is_verified: Boolean,&#10;        val from_camera: Boolean,&#10;        val recorded_at: String?,&#10;        val status: String&#10;    )&#10;    @Serializable&#10;    data class ScheduleStartTime(&#10;        val start_time: String&#10;    )&#10;&#10;    // Get attendance status for today&#10;    suspend fun getTodayAttendance(&#10;        userId: String,&#10;        scheduleId: Int,&#10;        courseId: Int&#10;    ): Result&lt;AttendanceRecord?&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Get enrollment_id&#10;            val enrollmentResult = supabase.postgrest[&quot;enrollments&quot;]&#10;                .select(columns = Columns.list(&quot;enrollment_id&quot;)) {&#10;                    filter {&#10;                        eq(&quot;user_id&quot;, userId)&#10;                        eq(&quot;course_id&quot;, courseId)&#10;                    }&#10;                }&#10;                .decodeList&lt;EnrollmentResult&gt;()&#10;&#10;            if (enrollmentResult.isEmpty()) {&#10;                return@withContext Result.success(null)&#10;            }&#10;&#10;            val enrollmentId = enrollmentResult.first().enrollment_id&#10;            val today = LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE)&#10;&#10;            val attendance = supabase.postgrest[&quot;attendances&quot;]&#10;                .select() {&#10;                    filter {&#10;                        eq(&quot;enrollment_id&quot;, enrollmentId)&#10;                        eq(&quot;schedule_id&quot;, scheduleId)&#10;                        eq(&quot;attendance_date&quot;, today)&#10;                    }&#10;                }&#10;                .decodeList&lt;AttendanceRecord&gt;()&#10;&#10;            return@withContext Result.success(attendance.firstOrNull())&#10;        } catch (e: Exception) {&#10;            return@withContext Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getCourseName(courseId: Int): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            val result = supabase.postgrest[&quot;courses&quot;]&#10;                .select(columns = Columns.list(&quot;course_name&quot;)) {&#10;                    filter { eq(&quot;course_id&quot;, courseId) }&#10;                }&#10;                .decodeList&lt;CourseData&gt;()&#10;            return@withContext result.firstOrNull()?.course_name&#10;        } catch (e: Exception) {&#10;            return@withContext null&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.smartattendance.api&#10;&#10;import io.github.jan.supabase.SupabaseClient&#10;import io.github.jan.supabase.postgrest.postgrest&#10;import io.github.jan.supabase.postgrest.query.*&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import kotlinx.serialization.Serializable&#10;&#10;class AttendanceApi(private val supabase: SupabaseClient) {&#10;&#10;    // Data class for attendance record&#10;    @Serializable&#10;    data class AttendanceRecord(&#10;        val attendance_id: Int? = null,&#10;        val enrollment_id: Int,&#10;        val schedule_id: Int,&#10;        val attendance_date: String,&#10;        val status: String,&#10;        val is_verified: Boolean = false,&#10;        val recorded_at: String? = null&#10;    )&#10;&#10;    @Serializable&#10;    data class EnrollmentResult(val enrollment_id: Int)&#10;&#10;    @Serializable&#10;    data class CourseData(&#10;        val course_name: String&#10;    )&#10;&#10;    // Submit attendance - check if exists, if not create, if exists update is_verified&#10;    suspend fun submitAttendance(&#10;        userId: String,&#10;        scheduleId: Int,&#10;        courseId: Int&#10;    ): Result&lt;Pair&lt;String, String&gt;&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Get enrollment_id&#10;            val enrollmentResult = supabase.postgrest[&quot;enrollments&quot;]&#10;                .select(columns = Columns.list(&quot;enrollment_id&quot;)) {&#10;                    filter {&#10;                        eq(&quot;user_id&quot;, userId)&#10;                        eq(&quot;course_id&quot;, courseId)&#10;                    }&#10;                }&#10;                .decodeList&lt;EnrollmentResult&gt;()&#10;            if (enrollmentResult.isEmpty()) {&#10;                return@withContext Result.failure(Exception(&quot;User is not enrolled in this course&quot;))&#10;            }&#10;            val enrollmentId = enrollmentResult.first().enrollment_id&#10;            val today = LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE)&#10;            // Check if attendance record already exists&#10;            val existingAttendance = supabase.postgrest[&quot;attendances&quot;]&#10;                .select(columns = Columns.list(&quot;attendance_id&quot;, &quot;is_verified&quot;, &quot;from_camera&quot;, &quot;recorded_at&quot;, &quot;status&quot;)) {&#10;                    filter {&#10;                        eq(&quot;enrollment_id&quot;, enrollmentId)&#10;                        eq(&quot;schedule_id&quot;, scheduleId)&#10;                        eq(&quot;attendance_date&quot;, today)&#10;                    }&#10;                }&#10;                .decodeList&lt;AttendanceResultWithCameraTime&gt;()&#10;            if (existingAttendance.isEmpty()) {&#10;                // Aturan 1: Insert new attendance row, status 'pending'&#10;                supabase.postgrest[&quot;attendances&quot;]&#10;                    .insert(AttendanceRecord(&#10;                        enrollment_id = enrollmentId,&#10;                        schedule_id = scheduleId,&#10;                        attendance_date = today,&#10;                        status = &quot;pending&quot;&#10;                    ))&#10;                return@withContext Result.success(Pair(&quot;Attendance submitted, waiting for verification&quot;, &quot;pending&quot;))&#10;            } else {&#10;                val attendance = existingAttendance.first()&#10;                // Aturan 4: Jika status bukan pending dan is_verified true, langsung redirect&#10;                if (attendance.status != &quot;pending&quot; &amp;&amp; attendance.is_verified) {&#10;                    return@withContext Result.success(Pair(&quot;Attendance already verified&quot;, attendance.status))&#10;                }&#10;                // Aturan 2: Jika is_verified false dan from_camera true&#10;                if (!attendance.is_verified &amp;&amp; attendance.from_camera) {&#10;                    // Get schedule start time&#10;                    val scheduleResult = supabase.postgrest[&quot;schedules&quot;]&#10;                        .select(columns = Columns.list(&quot;start_time&quot;)) {&#10;                            filter { eq(&quot;schedule_id&quot;, scheduleId) }&#10;                        }&#10;                        .decodeList&lt;ScheduleStartTime&gt;()&#10;                    val scheduleStart = scheduleResult.firstOrNull()?.start_time ?: &quot;07:15&quot;&#10;                    // Compare recorded_at time with schedule start time + 15 min&#10;                    val attendanceTime = attendance.recorded_at?.substring(11,16) ?: scheduleStart&#10;                    val startHour = scheduleStart.substring(0,2).toInt()&#10;                    val startMin = scheduleStart.substring(3,5).toInt()&#10;                    val toleranceHour = attendanceTime.substring(0,2).toInt()&#10;                    val toleranceMin = attendanceTime.substring(3,5).toInt()&#10;                    val startTotalMin = startHour * 60 + startMin&#10;                    val attendTotalMin = toleranceHour * 60 + toleranceMin&#10;                    val statusResult = if (attendTotalMin &lt;= startTotalMin + 15) &quot;present&quot; else &quot;late&quot;&#10;                    // Update is_verified and status&#10;                    supabase.postgrest[&quot;attendances&quot;]&#10;                        .update({&#10;                            set(&quot;is_verified&quot;, true)&#10;                            set(&quot;status&quot;, statusResult)&#10;                        }) {&#10;                            filter { eq(&quot;attendance_id&quot;, attendance.attendance_id) }&#10;                        }&#10;                    return@withContext Result.success(Pair(&quot;Attendance verified successfully&quot;, statusResult))&#10;                }&#10;                // Aturan 3: Jika is_verified false dan from_camera false&#10;                // This block is only reached if above conditions are not met&#10;                return@withContext Result.success(Pair(&quot;Attendance submitted, waiting for verification&quot;, &quot;pending&quot;))&#10;            }&#10;        } catch (_: Exception) {&#10;            return@withContext Result.failure(Exception(&quot;Attendance submission failed&quot;))&#10;        }&#10;    }&#10;&#10;    @Serializable&#10;    data class AttendanceResultWithCameraTime(&#10;        val attendance_id: Int,&#10;        val is_verified: Boolean,&#10;        val from_camera: Boolean,&#10;        val recorded_at: String?,&#10;        val status: String&#10;    )&#10;    @Serializable&#10;    data class ScheduleStartTime(&#10;        val start_time: String&#10;    )&#10;&#10;    // Get attendance status for today&#10;    suspend fun getTodayAttendance(&#10;        userId: String,&#10;        scheduleId: Int,&#10;        courseId: Int&#10;    ): Result&lt;AttendanceRecord?&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Get enrollment_id&#10;            val enrollmentResult = supabase.postgrest[&quot;enrollments&quot;]&#10;                .select(columns = Columns.list(&quot;enrollment_id&quot;)) {&#10;                    filter {&#10;                        eq(&quot;user_id&quot;, userId)&#10;                        eq(&quot;course_id&quot;, courseId)&#10;                    }&#10;                }&#10;                .decodeList&lt;EnrollmentResult&gt;()&#10;&#10;            if (enrollmentResult.isEmpty()) {&#10;                return@withContext Result.success(null)&#10;            }&#10;&#10;            val enrollmentId = enrollmentResult.first().enrollment_id&#10;            val today = LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE)&#10;&#10;            val attendance = supabase.postgrest[&quot;attendances&quot;]&#10;                .select() {&#10;                    filter {&#10;                        eq(&quot;enrollment_id&quot;, enrollmentId)&#10;                        eq(&quot;schedule_id&quot;, scheduleId)&#10;                        eq(&quot;attendance_date&quot;, today)&#10;                    }&#10;                }&#10;                .decodeList&lt;AttendanceRecord&gt;()&#10;&#10;            return@withContext Result.success(attendance.firstOrNull())&#10;        } catch (e: Exception) {&#10;            return@withContext Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getCourseName(courseId: Int): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            val result = supabase.postgrest[&quot;courses&quot;]&#10;                .select(columns = Columns.list(&quot;course_name&quot;)) {&#10;                    filter { eq(&quot;course_id&quot;, courseId) }&#10;                }&#10;                .decodeList&lt;CourseData&gt;()&#10;            return@withContext result.firstOrNull()?.course_name&#10;        } catch (e: Exception) {&#10;            return@withContext null&#10;        }&#10;    }&#10;&#10;    suspend fun getScheduleInfo(scheduleId: Int): ScheduleInfo? = withContext(Dispatchers.IO) {&#10;        try {&#10;            val result = supabase.postgrest[&quot;schedules&quot;]&#10;                .select(columns = Columns.list(&quot;day&quot;, &quot;start_time&quot;, &quot;end_time&quot;, &quot;room&quot;)) {&#10;                    filter { eq(&quot;schedule_id&quot;, scheduleId) }&#10;                }&#10;                .decodeList&lt;ScheduleInfo&gt;()&#10;            return@withContext result.firstOrNull()&#10;        } catch (e: Exception) {&#10;            return@withContext null&#10;        }&#10;    }&#10;&#10;    @Serializable&#10;    data class ScheduleInfo(&#10;        val day: String,&#10;        val start_time: String,&#10;        val end_time: String,&#10;        val room: String?&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/database_functions.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/database_functions.sql" />
              <option name="updatedContent" value="-- ==============================&#10;-- STORED PROCEDURES FOR STATISTICS&#10;-- ==============================&#10;&#10;-- Function untuk mendapatkan statistik keseluruhan user&#10;CREATE OR REPLACE FUNCTION get_user_statistics(p_user_id VARCHAR)&#10;RETURNS TABLE(&#10;    total_present BIGINT,&#10;    total_late BIGINT, &#10;    total_absent BIGINT,&#10;    total_meetings BIGINT,&#10;    attendance_percentage NUMERIC&#10;) AS $$&#10;BEGIN&#10;    RETURN QUERY&#10;    SELECT &#10;        COALESCE(SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END), 0) as total_present,&#10;        COALESCE(SUM(CASE WHEN a.status = 'late' THEN 1 ELSE 0 END), 0) as total_late,&#10;        COALESCE(SUM(CASE WHEN a.status = 'absent' THEN 1 ELSE 0 END), 0) as total_absent,&#10;        COALESCE(COUNT(a.attendance_id), 0) as total_meetings,&#10;        COALESCE(&#10;            ROUND(&#10;                SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) * 100.0 / &#10;                NULLIF(COUNT(a.attendance_id), 0), &#10;                2&#10;            ), &#10;            0&#10;        ) as attendance_percentage&#10;    FROM enrollments e&#10;    LEFT JOIN attendances a ON e.enrollment_id = a.enrollment_id&#10;    WHERE e.user_id = p_user_id;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;-- Function untuk mendapatkan statistik per mata kuliah&#10;CREATE OR REPLACE FUNCTION get_course_statistics(p_user_id VARCHAR)&#10;RETURNS TABLE(&#10;    course_code VARCHAR,&#10;    course_name VARCHAR,&#10;    total_pertemuan BIGINT,&#10;    hadir BIGINT,&#10;    terlambat BIGINT,&#10;    tidak_hadir BIGINT,&#10;    persentase_kehadiran NUMERIC&#10;) AS $$&#10;BEGIN&#10;    RETURN QUERY&#10;    SELECT &#10;        c.course_code,&#10;        c.course_name,&#10;        COUNT(a.attendance_id) as total_pertemuan,&#10;        SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) as hadir,&#10;        SUM(CASE WHEN a.status = 'late' THEN 1 ELSE 0 END) as terlambat,&#10;        SUM(CASE WHEN a.status = 'absent' THEN 1 ELSE 0 END) as tidak_hadir,&#10;        ROUND(&#10;            SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) * 100.0 / &#10;            NULLIF(COUNT(a.attendance_id), 0), &#10;            2&#10;        ) as persentase_kehadiran&#10;    FROM enrollments e&#10;    JOIN courses c ON e.course_id = c.course_id&#10;    LEFT JOIN attendances a ON e.enrollment_id = a.enrollment_id&#10;    WHERE e.user_id = p_user_id&#10;    GROUP BY c.course_code, c.course_name, c.course_id&#10;    ORDER BY c.course_code;&#10;END;&#10;$$ LANGUAGE plpgsql;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>